[TOC]

# 鸭子应用
这是一个模拟鸭子的应用
```java
public class Duck{
    public void quack();//呱呱叫
    public void swim();//游泳
    public abstract void display();//外观
}

public class RedDuck extends Duck{}
public class GreenDuck extends Duck{}
//很多其他子类...
```

## 第一个需求：让鸭子飞
起因是主管想要模拟会飞的鸭子将其它动物抛在后面。

### 第一种实现：继承-由超类实现
这种做法简单快捷，如果所有鸭子都会飞那自然很合适。

不过问题很快发生了，因为模拟的鸭子里包括橡皮鸭、木头鸭这种不会飞的鸭子，加在超类也会影响到这些鸭子，那么程序就有问题了。

可以利用继承解决，我们在子类中覆写这个方法，可以解决问题。不过这么做还是会有问题的，如果将所有公共的部分都交给超类实现，比如说这个类提供了`f1`、`f2`、`f3`等十多种公共方法，现在加了一个子类，这个子类只需要其中一两个方法，那么其他方法还必须要在子类覆写，这种做法对于新增类来说不是很麻烦吗？

利用继承提供`Duck`行为，会存在哪些问题：
1. 代码在多个子类中重复
1. 很难知道所有鸭子的全部行为
1. 运行时的行为不容易改变
1. 改变会牵一发而动全身，造成其他鸭子不想要的改变

### 第二种方案：接口-由子类实现
具体方案就是，超类只实现完全共享的方法，针对`fly`方法写一个`Flyable`接口，只有会飞的鸭子需要实现这个接口。

这个也很恶心，重复的代码会非常多，假设现在有40种会飞的鸭子，如果要调整`fly`行为，那就需要修改40次。【主要是接口不能实现方法，否则问题就解决了】

我们该如何解决这个问题？关键在于抽离变化，变化的部分单独处理，一般来说会有至少两个好处：
1. 封装，减少影响
2. 复用，方便维护

会变化的部分是什么？<br/>
是行为，每个类的类并不完全相同，其中存在相同行为的一部分类。

将这部分变化交由单独的类进行处理，既不在超类实现，也不在基类实现。

### 第三种方案：策略模式-封装行为类
行为类应该有一个公共接口`FlyBehavior`，针对这个公共接口实现两个类：
- `FlyWithWings`：会飞
- `FlyNoWay`：不会飞

#### 3.1 组合
我们首先使用组合的方式实现：
```java
abstract class Duck {
    protected FlyBehavior flyBehavior;//子类可以在构造器设置初始的默认行为

    public void performFly(){
        flyBehavior.fly();
    }
}

class RedDuck extends Duck{
    public RedDuck(){
        this.flyBehavior = new FlyWithWings();
    }
}
```
现在我们可以调用实例的`performQuack`方法进行飞行啦。 

再回顾下情况：
1. 现在我们可以自由改变行为而不影响到`Duck`子类
2. 现在我们将重复抽离出来了，可以复用代码，修改的时候也更方便，只需要修改一处

现在可以很方便的复用实现，我们知道：
1. 方法是抽象的，实现是具象的
1. 抽象是解耦的，抽象没有依赖，实现会产生依赖
1. 抽象可以被复用，实现不能被复用（或者说复用必然是抽象）

不过这种写法还是有一些问题：
1. 不能在运行中改变行为，灵活性不是那么高
2. 添加新的行为还是很麻烦：假如说现在有40个子类，其中30个都会飞，那么我们在添加行为时意味着可能要对30个类都进行修改

让我们再换一种实现

#### 3.2 聚合
```java
abstract class Duck {
    protected FlyBehavior flyBehavior;//子类可以在构造器设置初始的默认行为

    public void performFly() {
        flyBehavior.fly();
    }

    //其他地方都不用变，只要加上这个方法就可以聚合啦！
    public void setFlyBehavior(FlyBehavior flyBehavior) {
        this.flyBehavior = flyBehavior;
    }
}

```
现在我们可以在运行时改变行为啦

# 策略模式
## 定义
策略模式定义了算法族，分别封装起来，让它们相互之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

## 适用性
1. 许多相关类仅仅是行为有异。策略提供了一种用多个行为中的一个行为来配置要给类的方法
2. 需要使用一个算法的不同变体。比如说可能定义一些反映不同空间/时间权衡的算法
3. 算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构
4. 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，价格相关的条件分支移入它们各自的Strategy类中以代替这些条件语句

## 结构
见同目录下的`UML`图

## 参与者
1. `Strategy`：定义所有支持的算法的公共接口。`Context`使用这个接口来调用某`ConcreteStrategy`定义的算法
2. `ConcreteStrategy`：以`Strategy`接口实现某具体算法
3. `Context`
    - 用一个`ConcreteStrategy`来配置
    - 维护一个对`Stratyge`的引用
    - 可定义一个接口来让`Strategy`来访问它的数据
    
## 协作
- `Strategy`与`Context`相互作用以实现选定的算法。当算法被调用时，`Context`可以将该算法所需要的数据都传递给该`Strategy`。或者，`Context`可以将自身作为一个参数传递给`Strategy`进行操作，这样可以让`Stratyge`可以在需要时回调使用。
- `Context`将它的客户请求转发给它的`Stratyge`,客户通常创建并传递一个`ConcreteStrategy`对象给该`Context`，这样，客户仅与`Context`交互。通常有一系列的`ConcreateStrategy`可供客户从中选择

## 效果
### 优点
1. 相关算法系列：`Strategy`类层次为`Context`定义了一系列可供重用的算法或行为，方便复用
1. 替代继承：继承提供了另一种支持多种算法或行为的方案，可以直接生成`Context`子类，从而给它以不同的行为，但这回将行为硬编码到`Context`，而且会有重复。将算法的实现和`Context`实现耦合，会使得代码难以理解、难以维护和难以扩展，而且不能动态的改变算法。将算法独立封装使得我们可以独立于`Context`改变它，使它易于切换、易于理解、易于扩展
1. 消除了一些条件语句：将不同行为交由一个类负责时，很难避免使用条件语句进行选择，有时候将行为封装在`Strategy`中可以消除条件语句
1. 实现的选择：我们可以提供相同行为的不同，客户可以根据时间/空间权衡选择相应策略

### 缺点
1. 客户必须了解不同的`Strategy`：如果客户想要选择一个合适的`Strategy`，就需要了解这些`Strategy`的不同
1. `Strategy`和`Context`的通信开销：我们通过`Strategy`定义接口，可能有些`ConcreteStrategy`的算法不需要定义的参数，那么这个时候传递参数数据的开销就是多余的。当然也可以使用`Context`进行传递，然后根据需要去获取数据，但这种做法将使得`Stratyge`、`Context`进行更紧密的耦合。
1. 增加了对象的数目：只有需要一个`Strategy`的引用变量，有时候我们可以将`Strategy`实现为可供各`Context`共享的无状态对象来减少这一开销【？这里暂未理解】。

## 实现
### 1. 定义`Strategy`和`Context`接口 
两者必须使得`ConcreteStrategy`能够有效访问它所需要的`Context`中的任何数据，反义亦然【反之亦然在这里是什么意思？让`Context`的子类可以获取到`Strategy`的任何数据？】。
    
一种方法是让`Context`将数据放到参数中传递，这使得两者解耦，但是对一些`ConcreteStrategy`可能会接收到不需要的数据。

另一种方法是将`Context`作为参数传递，然后`Strategy`根据自己需要显示的调用API以获取所需数据——这使得`Context`必须对它的数据定义一个更为精细的接口，这将`Strategy`的`Context`更紧密的耦合在一起

### 2. 将`Strategy`作为模板参数
//待补充...

## 代码示例
见本目录下的示例代码

## 已知应用
//待补充...

## 相关模式
1. `FlyWeight`

# 知识
## 设计原则：抽离变化
将可能需要变化的部分独立出来，不要和不变的代码混在一起。

有一个简单的方法，如果每次新的需求，都需要修改某个地方的代码，那么就可以确定这部分代码需要被抽取出来，和稳定的代码进行区分。

抽离变化的原因是我们想减少修改影响的范围，让我们可以更容易修改和扩充变化的部分，而不影响到变化的部分。

设计模式的一个目标就在于此：修改变化的部分而不影响到其他部分。

## 设计原则：针对接口编程，而非实现编程
准确的说应该是针对超类型编程，即变量的声明类型应该是超类型，通常是一个抽象类或一个接口，这样，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这意味着，声明类时不用理会以后执行时的真正对象类型。

## 设计原则：多用组合，少用继承
当我们将两个类结合使用，就是组合。

利用组合建立系统具有更大的弹性，不仅可以将算法族封装成类，而且可以在运行时动态的改变行为，只要组合的行为对象复核接口标准。