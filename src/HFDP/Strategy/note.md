[TOC]

# 鸭子应用
这是一个模拟鸭子的应用
```java
public class Duck{
    public void quack();//呱呱叫
    public void swim();//游泳
    public abstract void display();//外观
}

public class RedDuck extends Duck{}
public class GreenDuck extends Duck{}
//很多其他子类...
```

## 第一个需求：让鸭子飞
起因是主管想要模拟会飞的鸭子将其它动物抛在后面。

### 第一种实现：将方案加在超类`Duck`上
这种做法简单快捷，如果所有鸭子都会飞那自然很合适。

不过问题很快发生了，因为模拟的鸭子里包括橡皮鸭、木头鸭这种不会飞的鸭子，加在超类也会影响到这些鸭子，那么程序就有问题了。

可以利用继承解决，我们在子类中覆写这个方法，可以解决问题。不过这么做还是会有问题的，如果将所有公共的部分都交给超类实现，比如说这个类提供了`f1`、`f2`、`f3`等十多种公共方法，现在加了一个子类，这个子类只需要其中一两个方法，那么其他方法还必须要在子类覆写，这种做法对于新增类来说不是很麻烦吗？

利用继承提供`Duck`行为，会存在哪些问题：
1. 代码在多个子类中重复
1. 很难知道所有鸭子的全部行为
1. 运行时的行为不容易改变
1. 改变会牵一发而动全身，造成其他鸭子不想要的改变

### 第二种方案：利用接口
具体方案就是，超类只实现完全共享的方法，针对`fly`方法写一个`Flyable`接口，只有会飞的鸭子需要实现这个接口。

这个也很恶心，重复的代码会非常多，假设现在有40种会飞的鸭子，如果要调整`fly`行为，那就需要修改40次。【主要是接口不能实现方法，否则问题就解决了】

我们该如何解决这个问题？关键在于抽离变化，变化的部分单独处理，一般来说会有至少两个好处：
1. 封装，减少影响
2. 复用，方便维护

会变化的部分是什么？<br/>
是行为，每个类的类并不完全相同，其中存在相同行为的一部分类。

将这部分变化交由单独的类进行处理，既不在超类实现，也不在基类实现。

### 第三种方法：设计专门的行为类
行为类应该有一个公共接口`FlyBehavior`，针对这个公共接口实现两个类：
- `FlyWithWings`：会飞
- `FlyNoWay`：不会飞

### 3.1 组合
我们首先使用组合的方式实现：
```java
abstract class Duck {
    protected FlyBehavior flyBehavior;//子类可以在构造器设置初始的默认行为

    public void performFly(){
        flyBehavior.fly();
    }
}

class RedDuck extends Duck{
    public RedDuck(){
        this.flyBehavior = new FlyWithWings();
    }
}
```
现在我们可以调用实例的`performQuack`方法进行飞行啦。 

现在可以很方便的复用实现，我们知道：
1. 方法是抽象的，实现是具象的
1. 抽象是解耦的，抽象没有依赖，实现会产生依赖
1. 抽象可以被复用，实现不能被复用（或者说复用必然是抽象）

不过这种写法还是有一些问题：
1. 不能在运行中改变行为，灵活性不是那么高
2. 添加新的行为还是很麻烦：假如说现在有40个子类，其中30个都会飞，那么我们在添加行为时意味着可能要对30个类都进行修改

让我们再换一种实现

### 3.2 聚合
```java
public class RedDuck extends Duck {
    private FlyBehavior flyBehavior;

    public RedDuck(FlyBehavior flyBehavior) {
        this.flyBehavior = flyBehavior;
    }

    public void setFlyBehavior(FlyBehavior flyBehavior) {
        this.flyBehavior = flyBehavior;
    }

    public void performFly(){
        flyBehavior.fly();
    }
}
```
现在我们可以在运行时改变行为啦

再回顾下情况：
1. 现在我们可以自由改变行为而不影响到`Duck`子类
2. 现在我们将重复抽离出来了，可以复用代码，修改的时候也更方便，只需要修改一处

# 知识
## 设计原则：抽离变化
将可能需要变化的部分独立出来，不要和不变的代码混在一起。

有一个简单的方法，如果每次新的需求，都需要修改某个地方的代码，那么就可以确定这部分代码需要被抽取出来，和稳定的代码进行区分。

抽离变化的原因是我们想减少修改影响的范围，让我们可以更容易修改和扩充变化的部分，而不影响到变化的部分。

设计模式的一个目标就在于此：修改变化的部分而不影响到其他部分。

## 设计原则：针对接口编程，而非实现编程
准确的说应该是针对超类型编程，即变量的声明类型应该是超类型，通常是一个抽象类或一个接口，这样，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这意味着，声明类时不用理会以后执行时的真正对象类型。