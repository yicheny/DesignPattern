[TOC]

# 设计模式
## 策略模式
策略模式定义了算法族，分别封装起来，让它们相互之间可以相互替换，此模式让算法的变化独立于使用算法的客户。

# 设计模式的目标
1. 修改变化的部分而不影响到其他部分
2. 复用代码

# 基础
## 抽象

## 封装

## 多态

## 继承
继承首先会造成的问题是紧耦合，父类修改必然会影响所有子类。其次是复用，不支持多类继承的语言中，继承使得复用的能力受到了限制。

不过继承未必要用于复用行为，继承有一个用处是统一接口，我们至少知道一件事继承统一超类的子类将拥有相同的”接口“，利用这一信息我们就可以使用在子类中做处理了。

不要用继承去复用行为【复用行为优先用组合】，用继承统一行为【继承使得子孙类获得相同的“接口“】。

# 原则
## 封装变化：找出应用中可能变化的部分，将它们独立出来
好处是让其他地方不受到影响，这样修改代码会减少意外的影响，系统更具有弹性

## 针对接口编程，不针对实现编程
准确的说应该是针对超类型编程，即变量的声明类型应该是超类型，通常是一个抽象类或一个接口，这样，只要是具体实现此超类型的类所产生的对象，都可以指定给这个变量。这意味着，声明类时不用理会以后执行时的真正对象类型。【这里，如果不使用超类型，声明类时需要考虑执行时的真正对象类型，但这会造成什么负面影响呢？】

## 设计原则：多用组合，少用继承
当我们将两个类结合使用，就是组合。

利用组合建立系统具有更大的弹性，不仅可以将算法族封装成类，而且可以在运行时动态的改变行为，只要组合的行为对象复核接口标准。

对于复用而言，继承有很大限制，比如我们想通过继承使用多个类的公共方法是难以做到的【因为Java不支持多累继承】，而组合则可以让我们同时复用多个类的方法。

另一点则是依赖性，继承是强依赖关系，组合是弱依赖，依赖的强弱意味着我们修改代码所带来的影响强弱。

## 设计原则：为了交互对象之间的松耦合设计而努力
实现松耦合的关键在于不依赖实现，依赖抽象。

松耦合可以让系统更具有弹性，消除修改代码的依赖影响，而且更容易复用类

以观察者模式而言，`Subject`依赖的是`Observer`的接口，只要实现了这个接口，都可以进行注册、移除、通知操作，所以我们不需要知道具体类是什么，做了什么或其他任何细节——只要满足`Observer`接口即可。

然后，如果有新的`Observer`类出现，我们不需要改动`Subject`代码。如果我们想让一个类成为观察者，我们只需要让它实现`Observer`接口即可。

而且在使用上也更加灵活，我们可以在运行时替换、删除、新增观察者，只要是满足`Observer`接口的类都是可以的，主题不会受到影响。

我的评价是和**针对接口编程，不针对实现编程**这一条原则联系密切，两者的连接点是：**针对抽象编程**

## 依赖倒置原则：要依赖抽象，不要依赖具体类
//待补充...

### 实践指导
1. 变量不可以持有具体类的引用【工厂类可以持有具体类引用】
2. 不要让类派生自具体类【继承具体类就会依赖具体体，继承应只继承抽象】
3. 不要覆盖基类中已实现的方法【如果覆盖基类已实现的方法，那么这个基类就不是一个真正适合被继承的抽象，基类中已实现的方法，应由所有子类共享而不允许重写】

# 我的思考
## `Solid`五项原则之间的关系
不遵守里氏替换原则，就无法遵守依赖倒转原则。<br/>
违反依赖倒转、接口隔离，就会进而违反单一职责。<br/>
违反单一职责，那么开放封闭也无法被保证。

## 方法与实现（抽象与具象）
1. 方法是抽象的，实现是具象的
1. 抽象是解耦的，抽象没有依赖，实现会产生依赖
1. 抽象可以被复用，实现不能被复用（或者说复用必然是抽象）